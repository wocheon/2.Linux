----------------리눅스 파일 시스템--------------------------------------

hdd구조 
여러개의 섹터가 모여서 트랙을 이루고
트랙이 옆으로 쌓여서 하나의 플레이트를 이룸
플레이트가 세로로 쌓여서 실린더를 형성

*리눅스에서는 섹터의 개수를 가지고 디스크의 용량을 정한다

hdd의 연결방식의 변화  IDE방식 > SATA방식,SCSI > ...

리눅스의 하드디스크 형식 
IDE방식(HD) 100mb > SATA방식,SCSI,USB (SD)> (VD) : virtual disk
ex ) SD a , SD b ... 
파티션 만들경우 > SD a1 SD a2 ....

*핫플러그기능 : 시스템이 꺼지지않은 상태에서도 하드디스크를 연결가능함
SATA2부터 가능해짐

lsblk  : 디스크 확인 명령어
sr0 : 일반적으로 dvd장치
디스크들은 : dev/에 들어있음 type : b
핫플러그 기능은있지만 따로 스캔할수있도록 명령어 입력필요 >echo ' - - -' > /sys/class/scsi_host/host0/scan
host:  디스크와 논리적으로 연결된 채널 , 일일이 확인해야함 > 쉘 스크립트를 작성해서도 실행가능
du 디렉토리 : 해당디렉토리의 사용여부 및 용량을 보여줌

파티션 방식 
파티션구성방식 :  MBR GPT
디스크하나에는 하나의 파티션방식만 가능함

MBR : 1980년대 생겨난 방식 주(Primary) 파티션 - 4개 or 주 파티션 3개+확장 파티션 1개로 구성
*주파티션 : 부팅이 가능한 파티션을 말함
확장파티션 : 논리파티션을 설정할수 있는 공간을 확보해주는파티션 (일반적으로 논리파티션은 11개까지 가능)
> 하나의 확장파티션안에 여러개의 논리파티션으로 구성가능, 실제로는 하나의 확장파티션으로 인식
인식용량이 최대 2TB까지만 가능
파티션의 정보를 담은 MBR table이 앞에 붙어있다

GPT : 1990년 후반에 생겨난 방식 
이론적으로는 무한대로 파티션이 가능.
but 실제적으로는 주 파티션 128개까지가능 (확장파티션이나 논리파티션이라는 개념 x)
최대 인식용량 : 8zb 까지 가능 (b-kb-mb-gb-tb-pb-eb-zb) 1zb = 10억 tb
파티션의 정보를 담은 MBR table이 앞,뒤에 붙어있다

*파티션을 만들때 파티션끼리 겹치거나 공백이 생기지 않도록 주의할것
겹치면 데이터 깨짐, 공백이생기면 공간이 낭비됨

*dos : disk operation system

리눅스에서는 xfs ext4를 주로 사용

blkid : 포맷을 했을때 장치명(UUID)을 알려주는 명령어
df -TH(mb,gb), df -Th(mib,gib)

fdisk - MBR 파티션
gdisk - GPT 
parted -MBR/GPT
교재 -333p ~426p

fdisk /dev/sb[x] 
새로운 파티션을 만들때 MBR테이블때문에 2048번 섹터 부터시작
3개의 파티션을 만들면 디폴트값이 e (extended)로 바뀜
extended파티션을 지우면 안의 논리파티션이 모두 지워짐
논리파티션은 5번부터시작


partprobe /dev/ 파티션을 만들고 입력해줘야 파티션 인식
gdisk 에는 hex code뒤에 00이붙는다 (4자리)

파티션 방식을 바꾸는 경우 o 나 g을 사용해서 다른방식의 파티션으로 
생성해야한다

포맷명령어 : mkfs -t(type) 포맷형식  파티션명 or mkfs.포맷형식 파티션명

vi /etc/fstab > 영구적인 마운트 설정
파일구성
     장치명 (UUID)/ 마운트 포인트/파일시스템 /옵션 /덤프유무/ 파일시스템 체크순서(부팅순서)
ex)  /dev/sdb1     /mnt/disk1       ext4      defaults  1              1
> 옵션들이 하나라도 잘못되면 부팅시 에러 발생( 특히 defaults주의)
기본시스템을 제외한 다른설정을 추가하는 경우 덤프유무와 파일시스템 체크순서는 1이상으로 잡아줌

장치명 : 반드시 파일시스템이 포맷되어있어야함 uuid로 대체가능

마운트 : 디스크에 접근할수있는 통로를 열어주는것 
디스크를 연결하면 특정위치에 마운트하여 사용하는 형식 > 마운트하지않으면 접근이불가능

마운트포인트 : 미사용중인 디렉토리어야함 (기존파일들은 마운트 해제 전까지 사용할수없음)

mount -a > /etc/fsatb 에 올라가있는 설정을 다올림
umount -a >  /etc/fsatb 에 올라가있는 설정을 다올림 , 단 사용중인것은 내릴수없음
umount시 해당디렉토리에 위치하고있으면 사용중으로 마운트해제가 안됨


*순서기억할것  파티션 나누고(fdisk/gdisk) > 포맷한뒤에(mkfs.xxx/mkfs -t ) > 마운트 (mount 장치명)

---------------------------------------swap---------------------------------------------------------

swap : 물리적디스크를 가상메모리처럼 사용하는 기능
포맷형식을 swap으로 설정해줘야함

/etc/fstab 에 옵션을 적을때 오류가 나더라도 크게 영향은 없음
swap설정시에는 덤프유무와 부팅순서는 0 으로 주는 편 ( 부팅시 메모리가 확보되면 성능향상이 가능하므로)

/etc/fstab에 올리는 경우 swap의 형식 > 장치 경로 swap swap defaults 0 0

swapon 장치명 : 해당장치를 swap으로 사용
swapon -s  : 현재 swap설정된 내용 확인
swapon -a : /etc/fstab 에 입력된 swap내용 올리기

swapoff 장치명 : 해당장치를 swap에서 사용해제
swapoff -a  : /etc/fstab 에 입력된 swap내용 전부 내림

mkswap 장치명 : 스왑으로 파일시스템 포맷

---------------------------------------LVM-----------------------------------------------------

logical volume manage 

여러개의 하드디스크를 합쳐서 하나의 파일시스템으로 사용
*RAID의 개념과 유사 > LVM로도 RAID를 구축가능

디스크 용량/ 제조사 /형식이 모두 같아야함
RAID 0 - span, stripe > 2개의 디스크를 합쳐서 한꺼번에 사용하는 방식
span 과  stripe의 차이점 
: span > 쌓는다. 두개의 디스크를 세로로 쌓아서 하나의 큰 디스크를 만드는것
stripe > 2개이상의 디스크를 가로로 합쳐서 하나의 디스크 처럼 사용하는것
안정성대신 성능을 택하는것

RAID 1 - mirroring  > 데이터를 기록할때 서로다른 두개의 디스크에 같은 데이터를
기록함  안정성좋음

RAID 5 - parity 사용 최소 3개의 디스크가 필요하며 기록되는 데이터의 parity bit를 만드는 방식
 데이터의 복원을 하는데 필요한 parity bit를 기록하는 방식

RAID 10 - 선 미러링 후 스트라이프
RAID 01 - 선  스트라이프 후 미러링 > 복원시에 10보다 복잡함


물리 볼륨 (Physical Volume)  : 파티션
볼륨 그룹 (Volume Group) : 물리볼륨을 합쳐서 1개의 물리그룹으로 만드는것 
논리 볼륨 (Logical Volume) : 볼륨그룹을 1개이상으로 나누어 논리그룹으로 나눈것

> 여러개의 물리 볼륨을 묶어서 하나의 볼륨그룹으로 만들고
그 볼륨그룹을 여러개의 파티션(논리볼륨)으로 나누어서 사용한다
*lv는 특정 물리 파티션에 속하는것이 아님 

논리볼륨 : 이름지정이 사용자지정으로 가능하고 확장필요시 사용중에도 명령어를 이용해 확장가능
최소단위 > PE(LE) 기본 4mib

PE 가 클수록 데이터를 처리하는 속도가 빠르지만 낭비가 심함
작을수록 효율적으로 사용이가능하지만 속도가 느림

pvcreate 장치명/파티션명
vgcreate 볼륨그룹명 장치1 장치 2... 
lvcreate 볼륨그룹명 옵션 용량

pvdisplay - pv지정 설정 확인명령어 (vgdisplay/lvdisplay)  -v (내용을 더 자세히 출력)
PE크기 변경 vgcreate 볼륨그룹명 장치1 장치 2... -s PE크기 (4의 배수로올림 다른숫자도 가능하긴함)
vgcreate vg1 /dev/sdb[24] -s 8 > 만들때 설정해야함 (이미 만들어진것은 바꿀수없음)
pv가 없는 상태에서 만들어도 자동적으로 pv를 생성하여 vg를 만든다

lvcreate 그룹명 -L 실제용량 > lvcreate vg0 -L 2G -n lv01

lvcreate 그룹명 -ㅣ 실제용량(LE개수)  > lvcreate vg0 -l 512 -n lv02

ls -l /dev/vg0/lv01 /dev/mapper/vg0-lv01
> lv생성시 두가지 경로가 생기고 둘중 어느 경로를 사용해도 관계없음
(시스템은 임의로 둘중하나를 선택하여 사용함)

lvcreate vg1 -l 100%FREE -n lv05 볼륨그룹에 있는 나머지 용량을 다꺼내서 쓰겠다

lv 삭제시에는 반드시 마운트 해제후 삭제해야함

lvremove 그룹명 장치명
vgremove 그룹명
pvremove  장치명

볼륨그룹 확장 : vgextend vg명 pv명...  > pv가 아닌경우 자동으로 pv로 변환된 후에 확장됨
볼륨그룹 축소 : vgreduce vg명 pv명...
물리볼륨 내용 이동 : pvmove pv명...

lv 확장시에 -r을 써주지않으면 실제 디스크 크기만 늘어나게된다
>파일시스템의 크기는 늘어나지않으므로 그대로인것처럼 보임
lsblk에서는 확장된것으로 보이지만 df -Th에서는 확장되어있지않음 
명령어를 사용하여 따로 파일시스템을 확장시켜주어야함

논리볼륨 확장 : lvextend lv경로 -r(파일시스템 확장)
xfs  파일시스템 확장 : xfs_growfs 마운트 포인트
ext4 파일시스템 확장 : resize2fs lv경로
swap인경우에는 사용은가능하지만  확장이 불가능  > swapoff시킨뒤 다시 swapon으로 진행

pvmove pv명 > 해당 pv의 데이터를 볼륨그룹의 나머지에게 재할당시킴

*vg내에 존재하는 한 파티션을 제거하는방법(pv로 설정되어있음) 제거시 순서

1.vg내에 현재 pv의 데이터를 옮길만큼의 용량이 남아있는지 확인

2.만약 디스크내에 충분한용량의 파티션이 남아있으면 그것을 사용
충분한용량이 없는경우 같거나 더 큰 용량의 디스크를 추가하기

3.추가한 디스크의 파티션을 추가한뒤 pv로 만들고 vgextend 로 vg에 포함시키기

4.pvmove를 사용하여 삭제할 디스크내의 lv를 같은 vg상의 다른 pv로 옮기기

5.vgreduce를 사용해 삭제할 디스크를 vg에서 제거한뒤  pv제거

6.fdisk를 사용하여 해당 파티션을 제거하고 partprobe 수행한뒤 확인

lvreduce : 존재하긴하지만 쓰지않는것을 권장 > 파일시스템을 줄이기전 lv를 줄이면 파일시스템이 깨짐
리눅스는 파일을 처음부터저장하는것이아닌 각가지로 저장하기때문

디스크를 교체해서 데이터를 옮기는 경우 기존 디스크보다 크기가 같거나 커야만 한다

